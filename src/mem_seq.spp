mod std::mem_seq;

use std::c::cstd;


cls MemSeq[T, M: std::Manipulator = std::Manipulator] {
    arr: std::cstd::c::c_arr[T];
}


sup[T, M: std::Manipulator] MemSeq[T, M] {
    @meta::static_method
        fn new() -> Self { ret std::MemSeq[T]{""" TODO """}; }

    @meta::static_method
        fn new_sized(size: std::Num) -> Self { ret std::MemSeq[T]{""" TODO """}; }

        fn with_get[U](self: &Self, n: std::Num, f: std::Fn[U, (T)]) -> std::Ret[std::Void, std::MemErr] {
        ret if n < self.length() {
            true => { f(&self.arr.get(i)); std::pass(); };
            else => std::fail(std::MemErr::new(""));
        };
    }

        fn take(self: &Self, n: std::Num) -> std::Ret[T, std::MemErr] {
        let result: T;
        M::move(&mut result, 0, &mut self.arr, index, std::size_of[T]());
        ret std::pass(result);
    }

        fn set(self: &mut Self, n: std::Num, obj: T) -> std::Ret[std::Void, std::MemErr] {
        M::move(&mut self.arr, index, item, 0, std::size_of[T]());
        ret std::pass();
    }

        fn del(self: &mut Self, n: std::Num) -> std::Ret[T, std::MemErr] {
        let result: T;
        M::move(&mut result, 0, &mut self.array, index, std::size_of[T]());
    }
}
