@meta::private
mod std::str_backend::rope_str;

use std::allocator::Allocator;
use std::char::Char;
use std::mem_seq::MemSeq;
use std::num::Num;
use std::string_backend::abstract_str::AbstractStr;


@meta::public
cls RopeStr[A: std::Allocator = std::Allocator, M: std::Manipulator = std::Manipulator] {
    @meta::protected mut data: std::MemSeq[std::Char];
    @meta::protected mut lhs: std::Opt[Self];
    @meta::protected mut rhs: std::Opt[Self];
    @meta::protected mut len: std::Num;
}


sup[A: std::Allocator, M: std::Manipulator] std::str_backend::RopeStr[A] {
    @meta::static_method
    @meta::public
    fn new(data: std::MemSeq[std::Char]) -> Self {
        ret std::str_backend::RopeStr{data, lhs: std::none(), rhs: std::none(), len: data.length()};
    }

    @meta::static_method
    @meta::public
    fn new(lhs: Self, rhs: Self) -> Self {
        let len = lhs.len + rhs.len;
        ret std::str_backend::RopeStr{data: std::MemSeq[std::Char]::new(), lhs, rhs, len};
    }
}


sup[A: std::Allocator, M: std::Manipulator] std::str_backend::AbstractStr[A] for std::str_backend::RopeStr[A] {
    @meta::public
    fn length(self: &Self) -> std::Num {
        ret self.len.copy();
    }

    @meta::public
    fn insert(self: &mut Self, index: std::Num, that: Self) -> std::Void {

    }

    @meta::public
    fn substring(self: &Self, start: std::Num, end: std::Num) -> Self {

    }
}
