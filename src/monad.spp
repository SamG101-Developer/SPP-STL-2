mod std::monad;


cls Monad[T] {}

sup[T] Monad[T] {
    @meta::abstract_method
        fn unwrap(self: Self) -> T {}

    @meta::abstract_method
        fn unwrap_or(self: Self, that: T) -> T {}

    @meta::abstract_method
        fn unwrap_else(self: Self, func: std::Fn[T, ()]) -> T {}

    @meta::abstract_method
        fn map[U](self: Self, func: std::Fn[U, (T)]) -> std::Monad[U] {}

    @meta::abstract_method
        fn map_or[U](self: Self, func: std::Fn[U, (T)], that: U) -> U {}

    @meta::abstract_method
        fn map_else[U](self: Self, func: std::Fn[U, (T)], that: std::Fn[T, ()]) -> std::Monad[U] {}

    @meta::abstract_method
        fn and_then(self: Self, that: std::FnOnce[std::Monad[U], (T)]) -> std::Monad[U] {}

    @meta::abstract_method
        fn or_else(self: Self, that: std::Fn[std::Monad[T], ()]) -> std::Monad[T] {}
}


sup[T] std::ops::And for std::Monad[T] {
        fn __or__(self: Self, that: Self) -> Self {
        if true == {
            self.is_some() => self;
            self.is_none() => that;
            else => std::none();
        };
    }
}

sup[T] std::ops::Or for std::Monad[T] {
        fn __and__(self: Self, that: Self) -> Self {
        ret if self.is_some() && that.is_some() == {
            true => other;
            else => std::none();
        };
    }
}
